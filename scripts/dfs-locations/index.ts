#!/usr/bin/env bun

interface Language {
  language_name: string;
  language_code: string;
}

interface Location {
  location_code: number;
  location_name: string;
  available_languages: Language[];
}

export interface LocationConfig {
  /** Location code for DataForSEO API */
  locationCode: number;
  /** Location identifier for database storage */
  locationName: string;
  /** Language name for DataForSEO API */
  languageName: string;
}

interface ApiResponse {
  version: string;
  status_code: number;
  status_message: string;
  time: string;
  cost: number;
  tasks_count: number;
  tasks_error: number;
  tasks: Array<{
    id: string;
    status_code: number;
    status_message: string;
    time: string;
    cost: number;
    result_count: number;
    path: string[];
    data: {
      api: string;
      function: string;
    };
    result: Location[];
  }>;
}

const username = process.env.DATAFORSEO_USERNAME;
const password = process.env.DATAFORSEO_PASSWORD;

if (!username || !password) {
  console.error("Error: Missing credentials");
  console.error("Please set DATAFORSEO_USERNAME and DATAFORSEO_PASSWORD environment variables");
  process.exit(1);
}

const credentials = btoa(`${username}:${password}`);

console.log("Fetching DataForSEO locations and languages...\n");

try {
  const response = await fetch(
    "https://api.dataforseo.com/v3/ai_optimization/ai_keyword_data/locations_and_languages",
    {
      method: "GET",
      headers: {
        Authorization: `Basic ${credentials}`,
        "Content-Type": "application/json",
      },
    }
  );

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data: ApiResponse = await response.json();

  if (data.status_code !== 20000) {
    throw new Error(`API error: ${data.status_message}`);
  }

  const locations = data.tasks[0]?.result || [];

  console.log(`Total locations: ${locations.length}\n`);

  // Sort by number of available languages (as a proxy for popularity)
  const sortedByLanguages = [...locations]
    .sort((a, b) => b.available_languages.length - a.available_languages.length)
    .slice(0, 20);

  console.log("Top 20 locations by language support (popularity indicator):");
  console.log("═".repeat(70));
  sortedByLanguages.forEach((loc, index) => {
    console.log(
      `${(index + 1).toString().padStart(2)}. ${loc.location_name.padEnd(40)} | Code: ${loc.location_code.toString().padStart(6)} | Languages: ${loc.available_languages.length}`
    );
  });

  // Show common major locations
  console.log("\n\nMajor locations:");
  console.log("═".repeat(70));
  const majorLocationNames = ["United States", "United Kingdom", "Canada", "Australia", "Germany", "France", "Japan", "India"];

  const majorLocationConfigs: LocationConfig[] = [];

  majorLocationNames.forEach((name) => {
    const loc = locations.find((l) => l.location_name === name);
    if (loc) {
      console.log(
        `${loc.location_name.padEnd(40)} | Code: ${loc.location_code.toString().padStart(6)} | Languages: ${loc.available_languages.length}`
      );

      // Add all language variants for this location
      loc.available_languages.forEach((lang) => {
        majorLocationConfigs.push({
          locationCode: loc.location_code,
          locationName: loc.location_name,
          languageName: lang.language_name,
        });
      });
    }
  });

  // Save major locations to file
  const outputPath = "./major-locations.ts";
  const fileContent = `// Generated by index.ts on ${new Date().toISOString()}
export interface LocationConfig {
  /** Location code for DataForSEO API */
  locationCode: number;
  /** Location identifier for database storage */
  locationName: string;
  /** Language name for DataForSEO API */
  languageName: string;
}

export const majorLocations: LocationConfig[] = ${JSON.stringify(majorLocationConfigs, null, 2)};
`;

  await Bun.write(outputPath, fileContent);
  console.log(`\n\n✓ Saved ${majorLocationConfigs.length} location configs to ${outputPath}`);

  console.log(`\nAPI Cost: $${data.cost.toFixed(4)}`);
  console.log(`Response time: ${data.time}`);
} catch (error) {
  console.error("Error:", error instanceof Error ? error.message : String(error));
  process.exit(1);
}
